import SockJS from 'sockjs-client';
import { Stomp } from '@stomp/stompjs';
import { WS_BASE_URL } from '../config';

class WebSocketService {
      private stompClient: any = null;
    private isConnected = false;
    private isConnecting = false;
    private reconnectAttempts = 0;
    private reconnectTimer: any = null;
  private eventListeners: Map<string, ((data: any) => void)[]> = new Map();
  private pingTimer: any = null;

  constructor() {
    // Khi m·∫°ng tr·ªü l·∫°i ‚Üí th·ª≠ reconnect ngay (kh√¥ng ƒë·ª£i backoff)
    window.addEventListener('online', () => {
      console.log('üåê Online - trying to reconnect WS if needed');
      if (!this.isConnected && !this.isConnecting) {
        this.connect();
      }
    });

    window.addEventListener('offline', () => {
      console.log('üåê Offline - WS will reconnect when online');
    });
  }

  // K·∫øt n·ªëi WebSocket (ƒë∆∞·ª£c guard ƒë·ªÉ tr√°nh connect tr√πng)
  connect() {
    try {
      if (this.isConnected || this.isConnecting) {
        console.log('üîÅ B·ªè qua connect: client ƒë√£', this.isConnected ? 'CONNECTED' : 'CONNECTING');
        return;
      }

      // Force real WebSocket connection for testing
      console.log('üîå Force connecting to real WebSocket server...');

      console.log('üîå ƒêang k·∫øt n·ªëi WebSocket...');
      this.isConnecting = true;
      
      const base = WS_BASE_URL || window.location.origin;
      
      // Connect to WebSocket broker
      const wsUrl = `${base}/ws`;
      console.log('üîå S·ª≠ d·ª•ng SockJS URL:', wsUrl);
      console.log('üîå Client origin: localhost:5173 ‚Üí Server: 103.90.227.18/ws');
      
      // T·∫°o STOMP client v·ªõi SockJS
      try {
        this.stompClient = Stomp.over(() => new SockJS(wsUrl));
      } catch (sockjsError) {
        console.error('‚ùå Failed to create SockJS connection:', sockjsError);
        this.isConnecting = false;
        this.emitEvent('connect_error', { error: 'Failed to create SockJS connection' });
        return;
      }
      
      // Enable debug logging
      this.stompClient.debug = (str: string) => {
        console.log('üîç STOMP Debug:', str);
      };

      // C·∫•u h√¨nh heartbeat v√† auto-reconnect c∆° b·∫£n (CompatClient API)
      this.stompClient.reconnectDelay = 5000;
      this.stompClient.heartbeatIncoming = 10000; // server ‚Üí client
      this.stompClient.heartbeatOutgoing = 10000; // client ‚Üí server

      // K·∫øt n·ªëi ƒë·∫øn STOMP server v·ªõi delay ƒë·ªÉ ƒë·∫£m b·∫£o connection ready
      setTimeout(() => {
        this.stompClient.connect(
          {}, // headers
          (frame: any) => {
            console.log('‚úÖ K·∫øt n·ªëi WebSocket th√†nh c√¥ng:', frame);
            this.isConnected = true;
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            if (this.reconnectTimer) {
              clearTimeout(this.reconnectTimer);
              this.reconnectTimer = null;
            }
            this.emitEvent('connect', { frame });
            
            // Subscribe v√†o c√°c topic v·ªõi delay
            setTimeout(() => {
              this.subscribeToTopics();
            }, 100);
            
            // Start ping timer to keep connection alive
            this.startPing();
          },
          (error: any) => {
            console.error('‚ùå L·ªói k·∫øt n·ªëi WebSocket:', error);
            console.error('‚ùå Error details:', {
              message: error.message,
              type: error.type,
              target: error.target?.url
            });
            this.isConnected = false;
            this.isConnecting = false;
            this.emitEvent('connect_error', { error: error.toString() });
            this.scheduleReconnect();
          }
        );
      }, 100);

      // Hook th√™m c√°c handler ƒë·ªÉ n·∫Øm vi·ªác ƒë√≥ng k·∫øt n·ªëi
      this.stompClient.onStompError = (frame: any) => {
        console.error('‚ùå STOMP ERROR frame:', frame?.headers?.message, frame?.body);
      };

      this.stompClient.onWebSocketClose = () => {
        console.warn('‚ö†Ô∏è WebSocket closed');
        this.isConnected = false;
        this.isConnecting = false;
        this.stopPing();
        this.scheduleReconnect();
      };

    } catch (error) {
      console.error('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi WebSocket:', error);
      this.emitEvent('connect_error', { error: 'Kh√¥ng th·ªÉ kh·ªüi t·∫°o k·∫øt n·ªëi' });
      this.isConnecting = false;
      this.scheduleReconnect();
    }
  }

  // Subscribe v√†o c√°c topic
  // 
  // Topics to subscribe:
  // - /topic/payments: Payment confirmation messages
  // - /topic/orders/deleted: Order deletion messages
  // - /topic/orders: Order update messages
  private subscribeToTopics() {
    console.log('üì° ƒêang subscribe v√†o c√°c topic...');
    console.log('üì° Connection status before subscription:', this.isConnected);
    console.log('üì° STOMP client connected:', this.stompClient?.connected);
    
    
    // Subscribe v√†o topic orders
    this.subscribe('/topic/orders', 'orders', (message) => {
      console.log('üì® Nh·∫≠n message t·ª´ /topic/orders:', message.body);
      try {
        const order = JSON.parse(message.body);
        console.log('üì¶ D·ªØ li·ªáu order:', order);
        this.emitEvent('order_update', order);
      } catch (error) {
        console.error('‚ùå L·ªói parse order message:', error);
      }
    });

    // Subscribe v√†o topic order deletions
    this.subscribe('/topic/orders/deleted', 'orders-deleted', (message) => {
      console.log('üì® Nh·∫≠n message t·ª´ /topic/orders/deleted:', message.body);
      let orderId = message.body;
      
      // X√≥a d·∫•u ngo·∫∑c k√©p n·∫øu c√≥
      if (orderId.startsWith('"') && orderId.endsWith('"')) {
        orderId = orderId.slice(1, -1);
        console.log('üì® Removed quotes from orderId:', orderId);
      }
      
      console.log('üóëÔ∏è Order b·ªã x√≥a:', orderId);
      console.log('üóëÔ∏è Emitting order_deleted event with orderId:', orderId);
      this.emitEvent('order_deleted', orderId);
    });

    // Subscribe v√†o topic payments
    this.subscribe('/topic/payments', 'payments', (message) => {
      console.log('üì® Nh·∫≠n message t·ª´ /topic/payments:', message.body);
      try {
        const payment = JSON.parse(message.body);
        console.log('üí≥ D·ªØ li·ªáu payment:', payment);
        this.emitEvent('payment_update', payment);
      } catch (error) {
        console.error('‚ùå L·ªói parse payment message:', error);
      }
    });

    // Subscribe v√†o topic order-item-marks
    this.subscribe('/topic/order-item-marks', 'order-item-marks', (message) => {
      console.log('üì® Nh·∫≠n message t·ª´ /topic/order-item-marks:', message.body);
      try {
        const evt = JSON.parse(message.body);
        // { orderId, itemId, marked }
        console.log('‚úÖ D·ªØ li·ªáu item mark:', evt);
        this.emitEvent('order_item_marked', evt);
      } catch (error) {
        console.error('‚ùå L·ªói parse order-item-marks message:', error);
      }
    });

    // Subscribe v√†o topic pong (echo t·ª´ ping)
    this.subscribe('/topic/pong', 'pong', (message) => {
      try {
        const pong = JSON.parse(message.body);
        console.log('üèì Received pong:', pong.ts, 'latency:', Date.now() - pong.ts, 'ms');
      } catch (error) {
        console.error('‚ùå L·ªói parse pong message:', error);
      }
    });
  }

  // Subscribe v√†o m·ªôt topic c·ª• th·ªÉ
  private subscribe(destination: string, id: string, callback: (message: any) => void) {
    console.log(`üîç Attempting to subscribe to ${destination}`);
    console.log(`üîç isConnected: ${this.isConnected}`);
    console.log(`üîç stompClient.connected: ${this.stompClient?.connected}`);
    console.log(`üîç stompClient exists: ${!!this.stompClient}`);
    
    if (!this.stompClient) {
      console.error(`‚ùå STOMP client not initialized for ${destination}`);
      return;
    }
    
    if (!this.isConnected) {
      console.warn(`‚ö†Ô∏è Not connected, cannot subscribe to ${destination}`);
      return;
    }
    
    if (!this.stompClient.connected) {
      console.warn(`‚ö†Ô∏è STOMP client not connected, cannot subscribe to ${destination}`);
      return;
    }
    
    try {
      console.log(`üîç Subscribing to ${destination}...`);
      const subscription = this.stompClient.subscribe(destination, callback);
      console.log(`‚úÖ ƒê√£ subscribe v√†o ${destination} v·ªõi id: ${id}`);
      console.log(`‚úÖ Subscription object:`, subscription);
      return subscription;
    } catch (error) {
      console.error(`‚ùå Kh√¥ng th·ªÉ subscribe v√†o ${destination}:`, error);
      console.error(`‚ùå STOMP client state:`, {
        connected: this.stompClient.connected,
        isConnected: this.isConnected
      });
    }
  }

  // Ng·∫Øt k·∫øt n·ªëi
  disconnect() {
    if (this.stompClient) {
      console.log('üîå Ng·∫Øt k·∫øt n·ªëi WebSocket');
      try {
        this.stompClient.disconnect(() => {
          console.log('üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi STOMP');
        });
      } catch {}
      this.isConnected = false;
      this.isConnecting = false;
      this.stopPing();
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
      }
    }
  }

  // Start ping timer to keep connection alive
  private startPing() {
    if (this.pingTimer) return;
    this.pingTimer = setInterval(() => {
      if (this.isConnected) {
        try {
          this.send('/app/ping', { ts: Date.now() });
        } catch (error) {
          console.warn('‚ö†Ô∏è Failed to send ping:', error);
        }
      }
    }, 25000); // Send ping every 25 seconds
    console.log('üèì Started ping timer');
  }

  // Stop ping timer
  private stopPing() {
    if (this.pingTimer) {
      clearInterval(this.pingTimer);
      this.pingTimer = null;
      console.log('üèì Stopped ping timer');
    }
  }

  // G·ª≠i message ƒë·∫øn server
  send(destination: string, message: any) {
    if (this.stompClient && this.isConnected) {
      try {
        this.stompClient.send(destination, {}, JSON.stringify(message));
        console.log(`üì§ ƒê√£ g·ª≠i message ƒë·∫øn ${destination}:`, message);
      } catch (error) {
        console.error(`‚ùå Kh√¥ng th·ªÉ g·ª≠i message ƒë·∫øn ${destination}:`, error);
      }
    } else {
      console.warn('‚ö†Ô∏è WebSocket ch∆∞a k·∫øt n·ªëi. Kh√¥ng th·ªÉ g·ª≠i message ƒë·∫øn:', destination);
    }
  }

  // L·∫Øng nghe events t·ª´ server
  on(event: string, callback: (data: any) => void) {
    console.log(`üì° ƒêƒÉng k√Ω listener cho event: ${event}`);
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event)!.push(callback);
  }

  // X√≥a event listener
  off(event: string) {
    if (this.eventListeners.has(event)) {
      console.log(`üßπ X√≥a listeners cho event: ${event}`);
      this.eventListeners.delete(event);
    }
  }

  // Emit internal events
  private emitEvent(event: string, data: any) {
    console.log(`üì° Emit event: ${event}`, data);
    const listeners = this.eventListeners.get(event);
    if (listeners && listeners.length > 0) {
      listeners.forEach((callback) => {
        try {
          callback(data);
        } catch (error) {
          console.error(`‚ùå L·ªói trong event listener cho ${event}:`, error);
        }
      });
    }
  }

  // Ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi
  getConnected() {
    return this.isConnected;
  }

     // L·∫•y STOMP client instance
   getStompClient() {
     return this.stompClient;
   }

   // L√™n l·ªãch reconnect v·ªõi backoff
   private scheduleReconnect() {
     if (this.reconnectTimer) {
       clearTimeout(this.reconnectTimer);
     }
     
     const delay = Math.min(5000 * Math.pow(2, this.reconnectAttempts), 20000); // max 20s thay v√¨ 30s
     this.reconnectAttempts++;
     
     console.log(`üîÑ L√™n l·ªãch reconnect sau ${delay}ms (attempt ${this.reconnectAttempts})`);
     
     this.reconnectTimer = setTimeout(() => {
       if (!this.isConnected && !this.isConnecting) {
         console.log('üîÑ Th·ª±c hi·ªán reconnect...');
         this.connect();
       }
     }, delay);
   }
 }

// T·∫°o singleton instance
const webSocketService = new WebSocketService();

export default webSocketService; 